function ShadowMontage_tiltseries_imageCTF()
% Prepare a tiltseries of shadow images from a tiltseries of 4DSTEM dataset in hdf5 format
% such as produiced by SavvyScan with DECTRIS Arina. Each tiltview is identified in the
% filename by S#, starting from number 0. The order of the tiltviews is according to order of acquisition.
% Written by Shahar Seifer, Weizmann Institute of Science, 2025
    
    nX=input('nX= ');
    nY=nX;
    required_nX=input('Render shodow images to size nX= ');
    
    cameraset=input('Camera size 96 / 192 / other ?  ');
    DECTRIS_Arina=input('Uses Dectris Arina ? [1-yes, 0-no] ');
    if DECTRIS_Arina
        isOldArina=input('Is it old Arina prototype? (0: no,  1:yes) ');
        if isOldArina==0  %new Arina
            caseno_checkDirection=input('Enter case number (1: underfocus, 4: overfocus) ')
        else
            caseno_checkDirection=input('Enter case number (3: underfocus, 2: overfocus) ')
        end
    else
        caseno_checkDirection=input('Enter direction case number [1,2,3,4]: ')
    end
    step_size_um=input('STEM step size [nm]? ')*0.001;
    thickness_pixels=input('Number of pixels in thickness direction: '); %I use not more than 500
    thickness_um=input('Thickness [um] (-1 for automatic): ');
    ignore_BF=input('Ignore BF and normalize to see edges ? (1-yes, 0-no) ')
    first_s=input('First S index in tilt series: ');
    end_s=input('End S index: ');
    step_s=input('Step s index: ');
    Ns_calc=input('Calculated synchronization step / or -1 based on image shift:  ');
    alpha_mrad=input('Convergence angle alpha [mrad]: ');
    alpha_rad=alpha_mrad/1000;
    d_nm=step_size_um*1000;
    
    K_keV=input('Enter electron energy in keV: ');
    lambda_nm= 1.2398/ sqrt(K_keV* (2 * 511 + K_keV)); % wavelength in nanometers (for 200KeV: 0.0025);
    
    
    sizeVOLx=required_nX;
    sizeVOLy=required_nX;
    sizeVOLz=thickness_pixels;
    
    
    if thickness_um==-1
        thickness_scale=1;
        thickness_um=thickness_pixels*(step_size_um*nX/sizeVOLx);
    else
        thickness_scale=(thickness_um/thickness_pixels)/(step_size_um*nX/sizeVOLx); %this is the true aspect ratio dz/dx of the 3d result
    end
    
    [filename,path] = uigetfile('z:\shared\ArinaData\*00001.h5','Fetch first HD5 file of s0 projection');
    
    ToUseALN=input('Use aln file from AreTomo for initial alignment (1) or skip (0): ');
    
    if ToUseALN==1
    
        [alnfilename,alnpath] = uigetfile('z:\shared\ArinaData\*.aln','Fetch aln file generated by AreTomo: ');
        nX_inSeries4alignment=input('nX in series for alignment= ');
        aln_Filename_file1=[alnpath alnfilename];
        alntable=readtable(aln_Filename_file1,'FileType','delimitedtext','NumHeaderLines' ,4,'VariableNamingRule','preserve',"ConsecutiveDelimitersRule","join");
        actual_angles_order=alntable.Var10; %tilt angle in deg
        actual_snumbers=alntable.Var1; %projection number 
        alignX_vector=alntable.Var4*nX/nX_inSeries4alignment;
        alignY_vector=(alntable.Var5*nX/nX_inSeries4alignment)./cos(pi*actual_angles_order/180);
        numtilts=length(actual_snumbers);
    else
        [alnfilename,alnpath] = uigetfile('z:\shared\ArinaData\*.rawtlt','Fetch rawtilt file: ');
        tiltfile=[alnpath alnfilename];
        fileID = fopen(tiltfile,'r');
        formatSpec = '%g';
        A = fscanf(fileID,formatSpec);
        fclose(fileID);
        NumTilts=length(A);
        theta_vec=single(A(1:NumTilts)*pi/180)';
        angles_rec = single(A(1:NumTilts))';
        actual_angles_order=angles_rec;
        actual_snumbers=first_s:step_s:end_s;%NumTilts-1;
        numtilts=NumTilts;
        alignX_vector=zeros(1,NumTilts);
        alignY_vector=zeros(1,NumTilts);
    end
    
    grandRec=zeros(sizeVOLx,sizeVOLy,sizeVOLz);
    
    fid=fopen('MyFile.txt','w');
    
    no_of_files=floor(((nX*nY)-1)/100000)+1;
    nXs=0;
    nXe=nX;
    nYs=0;
    nYe=nX;
    nXwin=nXe-nXs;
    nYwin=nYe-nYs;
    
    [qY, qX] = meshgrid( (1:cameraset)-(1+cameraset)/2,(1:cameraset)-(1+cameraset)/2);
    mask=zeros(cameraset,cameraset);
    index_out=0;
    movingavg_halfsize=3; %size of moving average
    q=sqrt(qX.^2+qY.^2);
    q1=1;
    q2=cameraset/2;
    mask_keep=false(cameraset,cameraset);
    mask_keep(q<=cameraset/3 )=true;
    
    
    
    s_number=first_s;
    filename1=strrep(filename,'_s0_',sprintf('_s%g_',s_number));
    Chosen_Filename_file1=[path filename1];
    newFilename=strrep(Chosen_Filename_file1,'.h5','_3dmontage.mrc');
    newFilename_tilt=strrep(Chosen_Filename_file1,'.h5','_Tiltview.mrc');
    
    
    newFilename_log=strrep(Chosen_Filename_file1,'.h5','_log.txt');
    fid=fopen(newFilename_log,'w');
    fprintf(fid, sprintf('scan_step[nm]=%g, result_stepX[nm]=%g, result_stepZ[nm]=%g,  thickness[um]=%g, alpha=%g,  Ns_synch=%g,  ignore_BF=%g, sizeVOLx=%g \n',step_size_um*1000,(step_size_um*nX/sizeVOLx)*1000,thickness_scale*(step_size_um*nX/sizeVOLx)*1000,thickness_um,alpha_mrad,Ns_calc,ignore_BF,sizeVOLx));
    fclose(fid);
    
    
    mat=h5read(Chosen_Filename_file1,'/entry/data/data');
    veclength=length(mat(1,1,:));
    probeim=uint16(zeros(cameraset,cameraset));
    for ind=1:10:veclength
        im=uint16(mat(:,:,ind));
        im(isnan(im))=0;
        im(im>60000)=0;
        probeim=probeim+im;
    end
    figure(1)
    balanced_imshow(probeim);
    probeimd=double(probeim);
    midv=(0.5*max(probeimd(:))+0.5*min(probeimd(:)));
    mask=probeimd>midv;
    BFdisc_diameter=2*sqrt(sum(mask(:))/pi);
    
    
    
    rere=nX*(0:nX-1)'+(1:nX);
    
    s_number_vector=actual_snumbers;
    for ind2_s_number=1:length(s_number_vector)
        s_number=s_number_vector(ind2_s_number);
        posg=0;
        tilt_angle_rad=actual_angles_order(ind2_s_number)*pi/180;
        alignX=alignX_vector(ind2_s_number);
        alignY=alignY_vector(ind2_s_number);
    
        filename1=strrep(filename,'_s0_',sprintf('_s%g_',s_number));
        Chosen_Filename_file1=[path filename1];
    
        mat=h5read(Chosen_Filename_file1,'/entry/data/data');
        veclength=length(mat(1,1,:));
        probeim=uint16(zeros(cameraset,cameraset));
        Xp=1;
        Yp=nY;
        for ind=1:10:veclength
            im=uint16(mat(:,:,ind));
            im(isnan(im))=0;
            im(im>60000)=0;
            probeim=probeim+im;
        
        end
        figure(1)
        balanced_imshow(probeim);
        
        
        probeimd=double(probeim);
        midv=(max(probeimd(:))+min(probeimd(:)))/2;
        mask=probeimd>midv;
        m_weight=(probeimd.*mask)/sum(sum(probeimd.*mask));
        [NqY,NqX] = meshgrid( (1:cameraset)-(1+cameraset)/2,(1:cameraset)-(1+cameraset)/2);
        Xd0=sum(NqX(mask).*m_weight(mask));
        Yd0=sum(NqY(mask).*m_weight(mask));
        mask_keep=true(size(mask));  
        mask_keep(sqrt((NqX-Xd0).^2+(NqY-Yd0).^2)>0.5*BFdisc_diameter-2)=false;
        mask_keep_q1=uint16(mask_keep & NqX>Xd0 & NqY>Yd0);
        mask_keep_q2=uint16(mask_keep & NqX>Xd0 & NqY<Yd0);
        mask_keep_q3=uint16(mask_keep & NqX<Xd0 & NqY<Yd0);
        mask_keep_q4=uint16(mask_keep & NqX<Xd0 & NqY>Yd0);
    
        
        veclength_vector=zeros(1,no_of_files);
        if Ns_calc<=0  %automatically determine synchronization step (best if the focus chages during titlt series acquisition
            for n=1:no_of_files
                Chosen_Filename_file=strrep(Chosen_Filename_file1,'0001.h5',sprintf('%04d.h5',n));
                mat=h5read(Chosen_Filename_file,'/entry/data/data');
                %mat_vector(:,:,1:size(mat,3),n)=mat;
                veclength=size(mat,3);
                veclength_vector(n)=veclength;
                indv=(1+posg):(veclength+posg);
                Xpv=mod(indv-1,nX)+1;
                for ind_file=1:veclength
                    ind=ind_file+posg;
                    Xp=1+mod((ind-1),nXwin);
                    Yp=1+floor((ind-1)/nXwin);
                    qm1(Xp,Yp)=sum(sum(uint16(mat(:,:,ind_file)).*(mask_keep_q1)));
                    qm2(Xp,Yp)=sum(sum(uint16(mat(:,:,ind_file)).*(mask_keep_q2)));
                    qm3(Xp,Yp)=sum(sum(uint16(mat(:,:,ind_file)).*(mask_keep_q3)));
                    qm4(Xp,Yp)=sum(sum(uint16(mat(:,:,ind_file)).*(mask_keep_q4)));
                end
                posg=posg+veclength;
            end
            %Use quadrant segment images to find image shifts
            [corr_offset(1,:),corr_offset(2,:),corr_offset(3,:),corr_offset(4,:)]=deshift(qm1,qm2,qm3,qm4); %regularly use deshift function , otherwise: deshift_ultramag
            shift_avg_pix=(abs(corr_offset(1,1))+abs(corr_offset(1,2))+abs(corr_offset(2,1))+abs(corr_offset(2,2))+abs(corr_offset(3,1))+abs(corr_offset(3,2))+abs(corr_offset(4,1))+abs(corr_offset(4,2)))/8;
            Ns_best=(BFdisc_diameter/(2*sqrt(2)))/max(0.5,shift_avg_pix); %based on center of mass of segment
        else
            Ns_best=Ns_calc;
        end
        %estimate how many different synchronizations are required based on the sample thickness and microscope settings 
        center_defocus_um=step_size_um*BFdisc_diameter/(Ns_best*2*alpha_mrad*0.001);
        Ns_min=max(2,step_size_um*BFdisc_diameter/((center_defocus_um+(thickness_um/2)/cos(tilt_angle_rad))*2*alpha_mrad*0.001));
        Ns_max=min(30,step_size_um*BFdisc_diameter/(max((center_defocus_um-(thickness_um/2)/cos(tilt_angle_rad)),0.5)*2*alpha_mrad*0.001));
        depth_max_um=step_size_um*BFdisc_diameter/(Ns_min*2*alpha_mrad*0.001);
        depth_min_um=step_size_um*BFdisc_diameter/(Ns_max*2*alpha_mrad*0.001);
        Ns_skip=max(0.5*round(2*(Ns_max-Ns_min)/10),0.5);
        Ns_min=Ns_skip*round(Ns_min/Ns_skip);
        Ns_max=Ns_skip*round(Ns_max/Ns_skip);
     
        disp(sprintf('Ns_min=%g  ,  Ns_max=%g  ,Ns_center=%g,   BF_diam. %d pix',Ns_min,Ns_max,Ns_best,BFdisc_diameter));
    
    
    
        dx_numbers_values=Ns_min:Ns_skip:Ns_max;
        allposvect=1:length(dx_numbers_values);
        stack_tiles=zeros(sizeVOLx,sizeVOLy,length(dx_numbers_values));
        startSafeParpool(6);
        parfor dx_numbers_pos=1:length(dx_numbers_values)  %shift numbers of different layers in the sample
            shift_step_camera=dx_numbers_values(dx_numbers_pos);
       
            calc_defocus_nm=BFdisc_diameter*step_size_um/(shift_step_camera*2*alpha_rad);
    
            
            im=double(zeros(cameraset,cameraset));
            caseno=caseno_checkDirection;
            if caseno>2
                xshift_dx=-shift_step_camera;
            else
                xshift_dx=shift_step_camera;
            end
            yshift_dx=0;
            xshift_dy=0;
            if caseno==1 || caseno==3
                yshift_dy=shift_step_camera; 
            else
                yshift_dy=-shift_step_camera; 
            end
            grand_result=double(zeros(round(2*cameraset+(abs(xshift_dy)*nYwin+abs(xshift_dx)*nXwin)),round(2*cameraset+(abs(yshift_dy)*nYwin+abs(yshift_dx)*nXwin))));
            x0=floor((2*cameraset+(abs(xshift_dy)*nYwin+abs(xshift_dx)*nXwin)*(1))/2);
            y0=x0;
        
            flag_debug=0;
            cos_orient_angle=1;
            sin_orient_angle=0;
            grand_tile=double(zeros(round(2*cameraset+(abs(xshift_dy)*nYwin+abs(xshift_dx)*nXwin)*(1)),round(2*cameraset+(abs(yshift_dy)*nYwin+abs(yshift_dx)*nXwin)*(1))));
            grand_count=uint16(zeros(round(2*cameraset+(abs(xshift_dy)*nYwin+abs(xshift_dx)*nXwin)*(1)),round(2*cameraset+(abs(yshift_dy)*nYwin+abs(yshift_dx)*nXwin)*(1))));
            posg=0;
            for n=1:no_of_files
                Chosen_Filename_file=strrep(Chosen_Filename_file1,'0001.h5',sprintf('%04d.h5',n));
                mat=h5read(Chosen_Filename_file,'/entry/data/data'); %Seems I must load from file to prevent memory crash
                veclength=size(mat,3);
                indv=(1+posg):(veclength+posg);
                Xpv=mod(indv-1,nX)+1;
                for ind_file=1:veclength
                    ind=ind_file+posg;
                    Xp=1+mod((ind-1),nXwin);
                    Yp=1+floor((ind-1)/nXwin);
                    %im=uint16(mat_vector(:,:,ind_file,n)).*uint16(mask_keep);
                    im=uint16(mat(:,:,ind_file)).*uint16(mask_keep);
                    if ignore_BF
                        im=double(im)/max(double(sum(im(:))),1); 
                    else
                        im=double(im);
                    end
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    % Here is the montage process
                    HR_Xc_nonrot=((Xp-nXwin/2)*xshift_dx+(Yp-nYwin/2)*xshift_dy);
                    HR_Yc_nonrot=((Xp-nXwin/2)*yshift_dx+(Yp-nYwin/2)*yshift_dy);
                    HR_Xc=(round(x0+cos_orient_angle*HR_Xc_nonrot+sin_orient_angle*HR_Yc_nonrot));
                    HR_Yc=(round(y0-sin_orient_angle*HR_Xc_nonrot+cos_orient_angle*HR_Yc_nonrot));
                    grand_tile(HR_Xc-(cameraset/2-1):HR_Xc+(cameraset/2),HR_Yc-(cameraset/2-1):HR_Yc+(cameraset/2))=grand_tile(HR_Xc-(cameraset/2-1):HR_Xc+(cameraset/2),HR_Yc-(cameraset/2-1):HR_Yc+(cameraset/2))+double(im);
                    grand_count(HR_Xc-(cameraset/2-1):HR_Xc+(cameraset/2),HR_Yc-(cameraset/2-1):HR_Yc+(cameraset/2))=grand_count(HR_Xc-(cameraset/2-1):HR_Xc+(cameraset/2),HR_Yc-(cameraset/2-1):HR_Yc+(cameraset/2))+uint16(mask_keep);
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    if flag_debug
                        figure(50)
                        balanced_imshow(grand_tile(HR_Xc-(2*cameraset):HR_Xc+(2*cameraset),HR_Yc-(2*cameraset):HR_Yc+(2*cameraset)))
                        pause(0.1)
                        figure(51)
                        balanced_imshow(grand_count(HR_Xc-(2*cameraset):HR_Xc+(2*cameraset),HR_Yc-(2*cameraset):HR_Yc+(2*cameraset)))
                        pause(0.1)
                    end
        
                end
                posg=posg+veclength;
            end
            grand_result(:,:)=grand_tile./double((uint16(grand_count==0)+grand_count));
            tileimage=grand_result(size(grand_result,1):-1:1,:);
           
            imageN=size(tileimage,1);
            [qYr, qXr] = meshgrid( (1:imageN)-(1+imageN)/2,(1:imageN)-(1+imageN)/2);
            qY_CTF=qYr/(imageN*d_nm/shift_step_camera);  %crystaligraphic convention without 2pi, in 1/nm units
            qX_CTF=qXr/(imageN*d_nm/shift_step_camera);
            q2_CTF=qX_CTF.^2+qY_CTF.^2;
            CTF=sin(pi*calc_defocus_nm*lambda_nm*q2_CTF);
            cor_CTF=sign(CTF)+(CTF==0);
    
            tileim_ft_cor=(fftshift(fft2(tileimage)))./cor_CTF;
            tileimage=real(ifft2(ifftshift(tileim_ft_cor)));
    
    
            margin=0.0625;
            required_nX=sizeVOLx;%input('required nX: ');
            required_nY=sizeVOLy;%input('required nY: ');
            tnX=size(tileimage,1);
            tnY=size(tileimage,2);
            vectx=1+margin*nX:tnX-margin*tnX;
            vecty=1+margin*nY:tnY-margin*tnY;
            image_croped=tileimage(round(vectx),round(vecty));
            im_resized=imresize(image_croped,[required_nX required_nY],"bilinear");
            %im_final=extract_balanced_imshow(im_resized);
            stack_tiles(:,:,dx_numbers_pos)=im_resized;
        
        
        end % for dx_numbers_pos
    
        vol3dCone_temp=zeros(sizeVOLx,3*sizeVOLy,sizeVOLz);
        for depth_ind=1:sizeVOLz
            depth=depth_min_um+(depth_ind-1)*(depth_max_um-depth_min_um)/sizeVOLz;
            Ns_suitable=step_size_um*BFdisc_diameter/(depth*2*alpha_mrad*0.001);
            Ns_round=round(Ns_suitable/Ns_skip)*Ns_skip;
            Ns_ind=allposvect(dx_numbers_values==Ns_round);
            ZminusZ0=depth_ind-(1+sizeVOLz)/2;
            slide_along_surface=ZminusZ0*thickness_scale*tan(tilt_angle_rad);
            vecty=round(slide_along_surface+(1+3*sizeVOLy)/2-(sizeVOLy/2)/cos(tilt_angle_rad)):round(slide_along_surface+(1+3*sizeVOLy)/2+(sizeVOLy/2)/cos(tilt_angle_rad));
            temp_img=stack_tiles(:,:,Ns_ind);
            vol3dCone_temp(1:sizeVOLx,vecty,depth_ind)=imresize(temp_img,[sizeVOLx length(vecty)],"bilinear");
    
        end
        
        vecty=round((1+3*sizeVOLy)/2-(sizeVOLy/2)):round((1+3*sizeVOLy)/2-(sizeVOLy/2))+sizeVOLy-1;
        vol3dCone=vol3dCone_temp(:,vecty,:);
        
        vecty_b=round((1+3*sizeVOLy)/2-(sizeVOLy/2)/cos(tilt_angle_rad)):round((1+3*sizeVOLy)/2+(sizeVOLy/2)/cos(tilt_angle_rad));
        tiltview_norm2=vol3dCone_temp(:,vecty_b,floor((1+sizeVOLz)/2));
        tiltview=imresize(tiltview_norm2,[sizeVOLx sizeVOLy],"bilinear");
        
        tiltview_norm=vol3dCone(:,:,floor((1+sizeVOLz)/2));
        tiltview(1:sizeVOLx,1+floor(0.5*sizeVOLy*(1-cos(tilt_angle_rad))):end-floor(0.5*sizeVOLy*(1-cos(tilt_angle_rad))))=imresize(tiltview_norm,[sizeVOLx sizeVOLy-2*floor(0.5*sizeVOLy*(1-cos(tilt_angle_rad)))],"bilinear");
        %%%
        tilt(:,:,ind2_s_number)=tiltview;
    
    
        newFilename_p=strrep(newFilename,'.mrc',sprintf('_S%g.mrc',s_number));
        newmRCImage = MRCImage;%Instentiate MRCImage object
        newmRCImage.filename=newFilename_p;
        newmRCImage = setVolume(newmRCImage, vol3dCone); %enter to newmRCImage, do statistics, and fill many details to the header
        save(newmRCImage, newFilename_p);
        close(newmRCImage);
    
    end %for ind2_s_number
    
    tilt_cor=tilt(end:-1:1,:,:); %make compatible with a seond method in orientation
    newmRCImage = MRCImage;%Instentiate MRCImage object
    newmRCImage.filename=newFilename_tilt;
    newmRCImage = setVolume(newmRCImage, tilt_cor); %enter to newmRCImage, do statistics, and fill many details to the header
    save(newmRCImage, newFilename_tilt);
    close(newmRCImage);

end



function corrected=extract_balanced_imshow(img)
    Nshades=1024;
    mapvector=linspace(0,1,Nshades)';
    cmap=zeros(Nshades,3);
    for loop=1:3
        cmap(:,loop)=mapvector;
    end
    try
        showpic2=balance(img,Nshades);
        corrected=showpic2; 
    catch
        corrected=img;
    end

    function normpic2=balance(normpic,Nshades)    
        [BinValues,BinEdges]=histcounts(normpic,Nshades);
        NumBins=length(BinValues);    
        sumH=sum(BinValues);
        temp=0;
        lowedge=BinEdges(NumBins);
        for n=1:NumBins-1
            temp=temp+BinValues(n);
            if temp>0.005*sumH
                lowedge=BinEdges(n);
            break;
            end
        end
        temp=0;
        highedge=BinEdges(1);
        for n2=NumBins:-1:2
            temp=temp+BinValues(n2);
            if temp>0.005*sumH
                highedge=BinEdges(n2);
            break;
            end
        end
        normpic(normpic>highedge)=highedge; %remove white dots
        normpic(normpic<lowedge)=lowedge; %remove black dots
        normpic2=((double(normpic)-lowedge)*Nshades)/double(highedge-lowedge);
    end 
end    

function startSafeParpool(desiredNumWorkers)
    % Get local cluster
    c = parcluster('local');

    % Determine the maximum allowed by the cluster
    maxClusterWorkers = c.NumWorkers;

    % Get number of physical cores available
    hwInfo = evalc('feature(''numCores'')');
    numCores = str2double(regexp(hwInfo, '\d+', 'match', 'once'));

    % Choose the safest number of workers
    safeNumWorkers = min([desiredNumWorkers, maxClusterWorkers, numCores]);

    % Start or reuse pool
    poolobj = gcp('nocreate');
    if isempty(poolobj)
        parpool(c, safeNumWorkers);
    else
        fprintf('Using existing pool with %d workers.\n', poolobj.NumWorkers);
    end
end
