function Backproject_align3d_afterAretomo()
%Build 3D reconstruction from the output of ShadowMontage_tiltseries and AreTomo alignement file    
%Written by Shahar Seifer, Weizmann Institute of Science, 2025
    
    first_s=input('First S in tiltseries: ');
    end_s=input('Final S in tiltseries: ');
    step_s=input('Steps in S: ');
    [filename,path] = uigetfile('z:\shared\ArinaData\*.mrc','Fetch first 3drec of individual tilt view: ');
    firstChosenFilname=[path filename];
    
    newRecfile=strrep(firstChosenFilname,sprintf('_S%d.mrc',first_s),'_AreTomoAlign3dRec.mrc');
    file_centerRecs=strrep(firstChosenFilname,sprintf('_S%d.mrc',first_s),'_ATcenterRecs.mrc');
    high_pass_do=input('Do extreme high pass?  (0-no,  1-yes): ')
    
    [alnfilename,alnpath] = uigetfile('z:\shared\ArinaData\*.aln','Fetch aln file generated by AreTomo: ');
    aln_Filename_file1=[alnpath alnfilename];
    alntable=readtable(aln_Filename_file1,'FileType','delimitedtext','NumHeaderLines' ,2,'VariableNamingRule','preserve',"ConsecutiveDelimitersRule","join");
    if size(alntable)*[0 1]'==1
        alntable=readtable(aln_Filename_file1,'FileType','delimitedtext','NumHeaderLines' ,3,'VariableNamingRule','preserve',"ConsecutiveDelimitersRule","join");
    end
    newlen=length(alntable.Var10)-sum(isnan(alntable.Var10));
    flag_fault_col1=false;
    if iscell(alntable.Var1)
        flag_fault_col1=true;
        alntable.Var1=zeros(size(alntable.Var2));
    end
    if sum(alntable.Var1==0)==0
        flag_fault_col1=true;
    end
    if flag_fault_col1
        sorted_alntable=sortrows(alntable,2);
        actual_angles_order=sorted_alntable.Var11(1:newlen); %tilt angle in deg
        actual_snumbers=sorted_alntable.Var2(1:newlen); %projection number, starting in zero
        alignX_vector=-sorted_alntable.Var5(1:newlen);
        alignY_vector=(sorted_alntable.Var6(1:newlen))./cos(pi*actual_angles_order/180);
    else
        sorted_alntable=sortrows(alntable,1);
        actual_angles_order=sorted_alntable.Var10(1:newlen); %tilt angle in deg
        actual_snumbers=sorted_alntable.Var1(1:newlen); %projection number, starting in zero
        alignX_vector=-sorted_alntable.Var4(1:newlen);
        alignY_vector=(sorted_alntable.Var5(1:newlen))./cos(pi*actual_angles_order/180);
    end
    snumber_vec0=first_s:step_s:end_s;  %min(end_s,first_s-step_s+(length(angles_rec))*step_s);
    snumber_vec1=snumber_vec0(actual_snumbers+1);
    ntilts=length(snumber_vec1);
    
    for snumber_index=1:length(snumber_vec1)
        snumber=snumber_vec1(snumber_index);
        angle=actual_angles_order(snumber_index);
        Chosen_Filename=strrep(firstChosenFilname,sprintf('_S%d.mrc',first_s),sprintf('_S%g.mrc',snumber));
        flgLoadVolume=1;  % If 1 - Load in the volume data (default: 1)
        showHeader=false; %  If 1 - Print out information as the header is loaded.
        mRCImage=MRCImage;%Instentiate MRCImage in mRCImage
        mRCImage = open(mRCImage, Chosen_Filename, flgLoadVolume, showHeader);
        rec1 = double(getVolume(mRCImage, [], [], []));
        numz=size(rec1,3);
        numzc=floor(numz/2);
        nX=size(rec1,1);
        centerec1=rec1(:,:,numzc);
        [row, col] = find(centerec1>0);
        RotTop = min(row)+3;
        RotBottom = max(row)-3;
        RotLeft = min(col)+3;
        RotRight = max(col)-3;
        if sum(centerec1(:))<10 || size(row,1)==0
             continue;
        end
        cropped_img = centerec1(RotTop:RotBottom, RotLeft:RotRight);
        cropped_img_local2=imresize(cropped_img,[round(0.01*(RotBottom-RotTop+1)) round(0.01*(RotRight-RotLeft+1))],'method','bicubic');
        cropped_img_local2=imresize(cropped_img_local2,[(RotBottom-RotTop+1) (RotRight-RotLeft+1)],'method','bicubic');
        if high_pass_do==1
            cropped_img_local=imresize(cropped_img,[round(0.05*(RotBottom-RotTop+1)) round(0.05*(RotRight-RotLeft+1))],'method','bicubic');
        else
            cropped_img_local=imresize(cropped_img,[round(0.02*(RotBottom-RotTop+1)) round(0.02*(RotRight-RotLeft+1))],'method','bicubic');
        end
        cropped_img_local=imresize(cropped_img_local,[(RotBottom-RotTop+1) (RotRight-RotLeft+1)],'method','bicubic');
        cropped_img_HP=cropped_img-cropped_img_local;
        centerec1_clean=zeros(size(centerec1));         
        centerec1_clean(RotTop:RotBottom, RotLeft:RotRight)=cropped_img_HP(1:end,1:end);
        h = fspecial('gaussian', [5 5], 3.0); % 3x3 kernel, sigma = 1.0
        if high_pass_do==1
            cropped_img_HP_skeleton=imfilter(2*cropped_img_HP+cropped_img_local2, h,'replicate');
        else
            cropped_img_HP_skeleton=imfilter(cropped_img_HP, h,'replicate');       
        end
    
        if snumber_index==1
            centerec1_reference_positive=cropped_img_HP_skeleton;
            centerec1_reference_negative=cropped_img_HP_skeleton;
            reference_RotLeft_positive=RotLeft;
            reference_RotRight_positive=RotRight;
            reference_RotBottom_positive=RotBottom;
            reference_RotTop_positive=RotTop;
            reference_RotLeft_negative=RotLeft;
            reference_RotRight_negative=RotRight;
            reference_RotBottom_negative=RotBottom;
            reference_RotTop_negative=RotTop;
            
            shiftsX=alignX_vector(snumber_index);
            shiftsY=alignY_vector(snumber_index);
            grandrec_sum=zeros(size(rec1));
            grandrec_count=zeros(size(rec1));
            stack_center=zeros(size(rec1,1),size(rec1,2),ntilts);
    
        else
            %shift 3d volume to place the align coorectly in xy, but without
            %changing z, according to previous alignmed image at the same side
            if angle>0
                reference_skeleton=centerec1_reference_positive;
                reference_RotTop=reference_RotTop_positive;
                reference_RotLeft=reference_RotLeft_positive;
                reference_RotBottom=reference_RotBottom_positive;
                reference_RotRight=reference_RotRight_positive;
            else
                reference_skeleton=centerec1_reference_negative;
                reference_RotTop=reference_RotTop_negative;
                reference_RotLeft=reference_RotLeft_negative;
                reference_RotBottom=reference_RotBottom_negative;
                reference_RotRight=reference_RotRight_negative;
            end
            
            shiftsX=alignX_vector(snumber_index);
            shiftsY=alignY_vector(snumber_index);
            
            if isnan(shiftsX)
                shiftsX=0;
            end
            if isnan(shiftsY)
                shiftsY=0;
            end
        end
        fillmean=median(cropped_img(:));
        fillmean_new=0;
        centerec1_cor=imtranslate(centerec1_clean,[-shiftsY -shiftsX],'FillValues',fillmean_new,'OutputView','same');
        stack_center(:,:,snumber_index)=centerec1_cor;
        if angle>0
            centerec1_reference_positive=cropped_img_HP_skeleton;
            reference_RotTop_positive=RotTop+shiftsX;
            reference_RotBottom_positive=RotBottom+shiftsX;
            reference_RotLeft_positive=RotLeft+shiftsY;
            reference_RotRight_positive=RotRight+shiftsY;
        else
            centerec1_reference_negative=cropped_img_HP_skeleton;
            reference_RotTop_negative=RotTop+shiftsX;
            reference_RotBottom_negative=RotBottom+shiftsX;
            reference_RotLeft_negative=RotLeft+shiftsY;
            reference_RotRight_negative=RotRight+shiftsY;
        end
    
        rec1_cor=zeros(size(rec1));
        rec1_cor_mask=zeros(size(rec1));
        for z=1:size(rec1,3)
            im=rec1(:,:,z);
            [row, col] = find(im>0);
            if sum(im(:))<10 || size(row,1)==0
                continue;
            end
            RotTop = min(row)+5;
            RotBottom = max(row)-1;
            RotLeft = min(col)+5;
            RotRight = max(col)-1;
            cropped_img = im(RotTop:RotBottom, RotLeft:RotRight);
            if high_pass_do==1
                cropped_img_local=imresize(cropped_img,[round(0.05*(RotBottom-RotTop+1)) round(0.05*(RotRight-RotLeft+1))],'method','bicubic');
            else
                cropped_img_local=imresize(cropped_img,[round(0.02*(RotBottom-RotTop+1)) round(0.02*(RotRight-RotLeft+1))],'method','bicubic');
            end
            cropped_img_local=imresize(cropped_img_local,[(RotBottom-RotTop+1) (RotRight-RotLeft+1)],'method','bicubic');
            cropped_img_HP=cropped_img-cropped_img_local;
            cropped_img_eva1=imgaussfilt(cropped_img_HP,7);
            cropped_img_eva2=cropped_img_eva1(11:end-10,11:end-10);
            normalization=std(cropped_img_eva2(:));
            im_clean=zeros(size(centerec1));
            im_clean(RotTop:RotBottom, RotLeft:RotRight)=cropped_img_HP(1:end,1:end);
            mask=false(size(im_clean));
            mask(RotTop:RotBottom, RotLeft:RotRight)=true;%(cropped_img>0);
            im_shift=imtranslate(im_clean,[(-shiftsY) (-shiftsX)],'FillValues',fillmean_new,'OutputView','same');
            mask_shift=imtranslate(mask*1,[(-shiftsY) (-shiftsX)],'FillValues',fillmean_new,'OutputView','same');
            mask_shift=1*(mask_shift>0);
            rec1_cor(:,:,z)=im_shift*1/normalization;
            rec1_cor_mask(:,:,z)=mask_shift;
        end
        grandrec_sum=grandrec_sum+rec1_cor;
        grandrec_count=grandrec_count+rec1_cor_mask;
    end
    
    grandrec=grandrec_sum./(grandrec_count+1*(grandrec_count==0));
    meanrec=mean(grandrec(grandrec_count>0));
    grandrec(grandrec_count==0)=meanrec;
    
    newmRCImage = MRCImage;%Instentiate MRCImage object
    newmRCImage.filename=file_centerRecs;
    newmRCImage = setVolume(newmRCImage, stack_center); %enter to newmRCImage, do statistics, and fill many details to the header
    save(newmRCImage, file_centerRecs);
    close(newmRCImage);
    
    newmRCImage = MRCImage;%Instentiate MRCImage object
    newmRCImage.filename=newRecfile;
    newmRCImage = setVolume(newmRCImage, grandrec); %enter to newmRCImage, do statistics, and fill many details to the header
    save(newmRCImage, newRecfile);
    close(newmRCImage);

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Find shift between images
%####################################################
function r_mn=r_mn(Imagem,Imagen,shift_limit,do_filt)
    margval=0.25;
    max_size=max(size(Imagem));
    already_margin=(size(Imagen)-size(Imagem))/2;
    if false %sum(already_margin)<0
        flag_switch=true;
        already_margin=-already_margin;
        temp=Imagem;
        Imagem=Imagen;
        Imagen=temp;
    else 
        flag_switch=false;
    end
    already_margin(already_margin<0)=0;

    ext_margin=floor(margval*max_size)*[1 1];
    tempx=floor(max(margval*size(Imagem,1)-already_margin(1),1));  % x are the row number, y is the col number (as observed with balanced_imshow). The rows progress along the first ordinate in Imagem/n.
    tempy=floor(max(margval*size(Imagem,2)-already_margin(2),1));
    tempux=size(Imagem,1)-tempx;%floor(0.85*size(Imagem,1));
    tempuy=size(Imagem,2)-tempy;%floor(0.7*size(Imagem,2));
    view_in=Imagem(tempx:tempux,tempy:tempuy);

    figure(2);
    subplot(1,2,1);
    balanced_imshow(view_in);
    subplot(1,2,2);
    balanced_imshow(Imagen);
    Imagen_ext=zeros(size(Imagen)+2*ext_margin);
    Imagen_ext(1+ext_margin(1):end-ext_margin(1),1+ext_margin(2):end-ext_margin(2))=Imagen;
    correlationOutput = normxcorr2(view_in,Imagen_ext);
    [maxCorrValue, maxIndex] = max(abs(correlationOutput(:)));
    [xpeak, ypeak] = ind2sub(size(correlationOutput),maxIndex(1));%find(correlationOutput==max(correlationOutput(:)));  xpeak is the row number
    xoffset = xpeak-0.5*(size(view_in,1)+size(Imagen_ext,1)-1);
    yoffset = ypeak-0.5*(size(view_in,2)+size(Imagen_ext,2)-1);
    yoffset2=yoffset;%+(ypeak2-256+30)/32;
    xoffset2=xoffset;%+(xpeak2-256+31)/32;
    if max(abs(xoffset),abs(yoffset))>max_size*0.5
        r_mn=[0 0];
    else
        if flag_switch
            r_mn=[-xoffset2 -yoffset2];
        else
            r_mn=[xoffset2 yoffset2];
        end
    end
end

