%Written by Shahar Seifer, Weizmann Institute of Science, 2025
clear;
close all;

numtilts=input('Number of tilt views? ');


nX=input('nX= ');
nY=nX;
cameraset=input('Arina camera size 96 / 192 ?  ');
reduced_size=input('Reduced camera size? ');
step_size_um=input('STEM step size [nm]? ')*0.001;
defocus_um=input('Over-focus (distance above center of sample) in um? ');
camera_length_um=input('Nominal camera length [mm]? ')*2*1e3; %actual in micrometers
[filename,path] = uigetfile('z:\shared\ArinaData\*00001.h5','Fetch first HD5 file of s0 projection');

[alnfilename,alnpath] = uigetfile('z:\shared\ArinaData\*.aln','Fetch aln file generated by AreTomo: ');
nX_inSeries4alignment=input('nX in series for alignment= ');
aln_Filename_file1=[alnpath alnfilename];
alntable=readtable(aln_Filename_file1,'FileType','delimitedtext','NumHeaderLines' ,4,'VariableNamingRule','preserve');
[res,ind]=sort(alntable.Var1);
actual_angles_order=alntable.Var10(ind);
alignX_vector=alntable.Var4(ind)*nX/nX_inSeries4alignment;
alignY_vector=alntable.Var5(ind)*nX/nX_inSeries4alignment;


sizeVOLx=2048;
sizeVOLy=2048;
sizeVOLz=200;
max_thickness_StepUnits=800;
%Changing to spatial units of step_size_um

min_x=-nX/2; 
max_x=nX/2;
min_y=-nY/2;
max_y=nY/2;
min_z=-max_thickness_StepUnits/2;
max_z=max_thickness_StepUnits/2;



no_of_files=floor(((nX*nY)-1)/100000)+1;
nXs=0;
nXe=nX;
nYs=0;
nYe=nX;
nXwin=nXe-nXs;
nYwin=nYe-nYs;
s_number=0;

[qY, qX] = meshgrid( (1:cameraset)-(1+cameraset)/2,(1:cameraset)-(1+cameraset)/2);
mask=zeros(cameraset,cameraset);
index_out=0;
movingavg_halfsize=3; %size of moving average
q=sqrt(qX.^2+qY.^2);
q1=1;
q2=cameraset/2;
mask_haadf=false(cameraset,cameraset);
mask_haadf(q>=q1 & q<=q2)=true;

filename1=strrep(filename,'_s0_',sprintf('_s%g_',s_number));
Chosen_Filename_file1=[path filename1];
mat=h5read(Chosen_Filename_file1,'/entry/data/data');
veclength=length(mat(1,1,:));
probeim=uint16(zeros(cameraset,cameraset));
for ind=1:10:veclength
    im=uint16(mat(:,:,ind));
    im(isnan(im))=0;
    im(im>60000)=0;
    probeim=probeim+im;
end
figure(1)
balanced_imshow(probeim);
newFilename=strrep(Chosen_Filename_file1,'.h5','_cone_rec.mrc');


probeimd=double(probeim);
midv=(0.1*max(probeimd(:))+0.9*min(probeimd(:)));
mask=probeimd>midv;
BFdisc_diameter=2*sqrt(sum(mask(:))/pi);
m_weight=(probeimd.*mask)/sum(sum(probeimd.*mask));
[NqY,NqX] = meshgrid( (1:cameraset)-(1+cameraset)/2,(1:cameraset)-(1+cameraset)/2);
Xd0=sum(NqX(mask).*m_weight(mask));
Yd0=sum(NqY(mask).*m_weight(mask));
mask_keep=false(size(mask));  
mask_keep(abs(NqX-Xd0)<=0.5*BFdisc_diameter/sqrt(2) & abs(NqY-Yd0)<=0.5*BFdisc_diameter/sqrt(2))=true;
ind_vec=1:cameraset*cameraset;
[keep_row,keep_col]=ind2sub(size(mask_keep),ind_vec(mask_keep(:)));
keep_row_vec=min(keep_row(:)):max(keep_row(:));
keep_col_vec=min(keep_col(:)):max(keep_col(:));
keep_demo=im(keep_row_vec,keep_col_vec);
reduced_size_factor=floor(length(keep_row_vec)/reduced_size);
reduced_size_margin=floor((length(keep_row_vec)-reduced_size_factor*(reduced_size-1))/2);
keep_demo_blur=imgaussfilt(keep_demo,reduced_size);
keep_row_vec_reduced=1+reduced_size_margin:reduced_size_factor:length(keep_row_vec);
keep_col_vec_reduced=1+reduced_size_margin:reduced_size_factor:length(keep_row_vec);

reduced_size=length(keep_row_vec_reduced); %recalculate reduced size (overwrite user's input)

if cameraset<=192 %Arina
    camera_step_um=(20000/cameraset)*reduced_size_factor;  %active area 20mm of ARINA DECTRIS 
else %ELA
    camera_step_um=(38400/cameraset)*reduced_size_factor;  %active area 20mm of ARINA DECTRIS 
end

%ASTRA TOOLBOX cone_vec 3D reconstruction
%Create a 3D cone beam geometry specified by 3D vectors.
%det_row_count: number of detector rows in a single projection
%det_col_count: number of detector columns in a single projection
%vectors: a matrix containing the actual geometry.
%Each row of vectors corresponds to a single projection, and consists of:
%( srcX, srcY, srcZ, dX, dY, dZ, uX, uY, uZ, vX, vY, vZ )
%src : the ray source
%d : the center of the detector
%u : the vector from detector pixel (0,0) to (0,1)
%v : the vector from detector pixel (0,0) to (1,0)

posg=0;
proj_data_mat_full=zeros(reduced_size,numtilts*nX*nY,reduced_size);
proj_vectors_full=zeros(numtilts*nX*nY,12);
s_number_vector=0:(numtilts-1);
for s_number=s_number_vector
    tilt_angle_rad=actual_angles_order(s_number+1)*pi/180;
    alignX=alignX_vector(s_number+1);
    alignY=alignY_vector(s_number+1);
    filename1=strrep(filename,'_s0_',sprintf('_s%g_',s_number));
    Chosen_Filename_file1=[path filename1];

    for n=1:no_of_files
        Chosen_Filename_file=strrep(Chosen_Filename_file1,'0001.h5',sprintf('%04d.h5',n));
        mat=h5read(Chosen_Filename_file,'/entry/data/data');
        veclength=length(mat(1,1,:));
        indv=(1+posg):(veclength+posg);
        Xpv=mod(indv-1,nX)+1;
        for ind_file=1:veclength
            ind=ind_file+posg;
            Xp=1+mod((ind-1),nXwin);
            Yp=1+floor((ind-1)/nXwin);
            im=double(mat(:,:,ind_file));
            im_sub=im(keep_row_vec,keep_col_vec);
            im_sub_blur=imgaussfilt(im_sub,reduced_size/2);
            im_extract=im_sub_blur(keep_row_vec_reduced,keep_col_vec_reduced);
            %all length scaled by step_size_um of probe
            srcX=(Xp-(nX+1)/2+alignX);
            srcY=(Yp-(nY+1)/2-alignY)+tan(tilt_angle_rad)*defocus_um/step_size_um;
            srcZ=-defocus_um/step_size_um;
            dX=srcX;
            dY=srcY*cos(tilt_angle_rad)*cos(tilt_angle_rad)-camera_length_um*sin(tilt_angle_rad)/step_size_um;
            dZ=srcY*cos(tilt_angle_rad)*sin(tilt_angle_rad)+camera_length_um*cos(tilt_angle_rad)/step_size_um;
            vX=camera_step_um/step_size_um;
            vY=0;
            vZ=0;
            uX=0;
            uY=camera_step_um*cos(tilt_angle_rad)/step_size_um;
            uZ=-camera_step_um*sin(tilt_angle_rad)/step_size_um;

            proj_vectors_full(ind,:)=[srcX srcY srcZ dX dY dZ uX uY uZ vX vY vZ];
            proj_data_mat_full(:,ind,:)=permute(im_extract-mean(im_extract(:)),[2 3 1]); % order should be: column(=x), angle, rows=y


        end

        posg=posg+veclength;
    end



end

%proj_data_mat=permute(proj_data_mat,[3 2 1]);


%im_extract=imcrop(im,resize_windw);


%grand4dstem=zeros(reduced_size,reduced_size,numtilts,nX*nY);


det_row_count=reduced_size;
det_col_count=reduced_size;

vec_temp=1:length(proj_vectors_full(:,1));
vec_temp_shuffled=vec_temp(randperm(length(vec_temp)));
vec_select=vec_temp_shuffled(1:min(10000000,length(vec_temp_shuffled)));
proj_vectors=(proj_vectors_full(vec_select,:));
proj_data_mat=single(proj_data_mat_full(end:-1:1,vec_select,:));

proj_geom = astra_create_proj_geom('cone_vec',  det_row_count, det_col_count, proj_vectors);

vol_geom = astra_create_vol_geom(sizeVOLx,sizeVOLy,sizeVOLz,min_x, max_x, min_y, max_y, min_z, max_z);

rec_id = astra_mex_data3d_c('create', '-vol', vol_geom, 0); %0- initializer

%proj_id = astra_mex_data3d('create', '-proj3d', proj_geom, proj_data_mat);
proj_id = astra_mex_data3d_c('link', '-proj3d', proj_geom, proj_data_mat,1); %0-unshared, 1-shared memory
%cfg = astra_struct('SIRT3D_CUDA');
%cfg = astra_struct('FDK_CUDA');
%cfg = astra_struct('CGLS3D_CUDA');
cfg = astra_struct('BP3D_CUDA');
cfg.ReconstructionDataId = rec_id;
cfg.ProjectionDataId = proj_id;

alg_id = astra_mex_algorithm_c('create', cfg);
% Run 50 iterations of the algorithm
%astra_mex_algorithm_c('iterate', alg_id,50);
astra_mex_algorithm_c('run', alg_id);
% Get the result
rec = astra_mex_data3d_c('get', rec_id);%maybe 'get_single'

rec_cor=rec(end:-1:1,:,:);
newmRCImage = MRCImage;%Instentiate MRCImage object
newmRCImage.filename=newFilename;
newmRCImage = setVolume(newmRCImage, rec_cor); %enter to newmRCImage, do statistics, and fill many details to the header
save(newmRCImage, newFilename);
close(newmRCImage);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Order tilt-angles 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function actual_angles_order=function_angle_reorder(stepa,grp,maxa,direction)
    remove_ntilt=0;  %How many tilt view to exclude from end of series
    remove_minus=0; %How many negative angles to exclude
    remove_plus=0;  %How many positive angles to exclude
    stop_after_x_counts=0; %should be 0 or -1 to skip this option
    reject_angle=[90 90]; %list of 2 angles to exclude 
    reject_count=[0 0];   %exclude=1, ignore=0
    ds_ISupto=0; %0= ignore, 1= if dose sym up to certain angle written in ds_uptoangle
    ds_uptoangle=60;
    angle_vector=0;
    if ds_ISupto
        ve=0:stepa:maxa;
        maxa_ds=max(ve(ve<=ds_uptoangle));
    else
        maxa_ds=maxa;
    end
    cnttostop=1;
    flag_stop=false;
    for ind=1:ceil((maxa_ds/stepa)/grp)
        grpnow=grp;
        if ind>((maxa_ds/stepa)/grp)
            grpnow=(((maxa_ds/stepa)/grp)-floor(((maxa_ds/stepa)/grp)))*grp;
        end
        if direction==1
            for memgrp=1:grpnow
                if ~flag_stop
                    angle_vector=[angle_vector -((ind-1)*grp+memgrp)*stepa];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
            for memgrp=1:grpnow
                if ~flag_stop
                    angle_vector=[angle_vector ((ind-1)*grp+memgrp)*stepa];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
        else
            for memgrp=1:grpnow
                if ~flag_stop
                    angle_vector=[angle_vector ((ind-1)*grp+memgrp)*stepa];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
            for memgrp=1:grpnow
                if ~flag_stop
                    angle_vector=[angle_vector -((ind-1)*grp+memgrp)*stepa];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
        end
    end
    if ds_ISupto
        if direction==1
            for ind=(maxa_ds+stepa):stepa:maxa
                if ~flag_stop
                    angle_vector=[angle_vector -ind];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
            for ind=maxa_ds+stepa:stepa:maxa
                if ~flag_stop
                   angle_vector=[angle_vector +ind];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
        else
            for ind=(maxa_ds+stepa):stepa:maxa
                if ~flag_stop
                    angle_vector=[angle_vector ind];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
            for ind=maxa_ds+stepa:stepa:maxa
                if ~flag_stop
                    angle_vector=[angle_vector -ind];
                end
                cnttostop=cnttostop+1;
                if cnttostop==stop_after_x_counts
                    flag_stop=true;
                end
            end
        end
    end
    
    %example: angle_vector=[0 -3 -6 -9 3 6 9 -12 -15 -18 12 15 18 -21 -24 -27 21 24 27 -30 -33 -36 30 33 36 -39 -42 -45 39 42 45 -48 -50.5 48 51 54 57 60 63 -51 -54 -57 -60]; %for file tomo28
    
    [angles_order,pos_angle_vector]=sort(angle_vector); 
    actual_angles_order=angle_vector;

end
