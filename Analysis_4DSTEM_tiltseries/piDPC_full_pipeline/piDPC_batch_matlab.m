% Generate parallax iDPC contrast (piDPC) from 4DSTEM data in h5 files generated by python
% Written by Shahar Seifer, Elbaum lab, Weizmann Insititute of Science 2025
% GPLv3 license

[filename,path] = uigetfile('*.h5','Fetch hdf5 file of a complete 4D-STEM data.');
Chosen_Filename=[path filename];


no_of_files=11;
nX=1024;
nY=1024;
mat=zeros(96,96,nX*nY);
Xp=1;
Yp=nY;
posg=1;
for n=1:no_of_files
    Chosen_Filename_file=strrep(Chosen_Filename,'0001.h5',sprintf('%04d.h5',n));
    mat_temp=h5read(Chosen_Filename_file,'/entry/data/data');
    veclength=length(mat_temp(1,1,:));
    for ind=1:veclength
        im=double(mat_temp(:,:,ind));
        im(isnan(im))=0;
        mat(:,:,posg)=im;
        posg=posg+1;
        if Xp==nX
            Xp=1;
            Yp=Yp-1;
            if Yp==0
                break;
            end
        else
            Xp=Xp+1;
        end

    end
end




Chosen_Filename_ch1=strrep(Chosen_Filename,'.h5','_sect1.mrc');
function_Arinatomo_rings_v9(mat,Chosen_Filename,nX);


for channel=1:8
    Chosen_Filename=strrep(Chosen_Filename_ch1,'sect1',sprintf('sect%d',channel));
    if channel==1
        newFilename11=strrep(Chosen_Filename,'sect1','piDPC');
    end
    mRCImage=MRCImage;%Insentiate MRCImage in mRCImage
    mRCImage = open(mRCImage, Chosen_Filename, 1, 1);
    tilt = double(getVolume(mRCImage, [], [], []));
    ntilts = length(tilt(1,1,:));%
    nX = getNX(mRCImage);
    nY = getNY(mRCImage);
    sizeXangstrom=getCellX(mRCImage);
    sizeYangstrom=getCellY(mRCImage);
    
    if channel==1
        tilts_channels=double(zeros(nX,nY,ntilts,4));
    end
    sect2quad=[2 2 3 3 4 4 1 1];
    Quad_channel=sect2quad(channel);
    tilts_channels(:,:,:,Quad_channel)=tilts_channels(:,:,:,Quad_channel)+tilt;
end

vnx=1:nX;
vny=1:nY;
[Y, X] = meshgrid( (1:nY)-(1+nY)/2,(1:nX)-(1+nX)/2);
[y, x] = meshgrid( 1:nY,1:nX);
kyp=Y/(nY);
kxp=X/(nX); 
kpnorm2=kxp.^2+kyp.^2;
kpnorm2(kpnorm2==0)=1e-6;
kpnorm=sqrt(kxp.^2+kyp.^2);

iDPC11tilt=zeros(nX,nY,ntilts);

for tiltno=1:ntilts
    img1=tilts_channels(:,:,tiltno,1);
    img2=tilts_channels(:,:,tiltno,2);
    img3=tilts_channels(:,:,tiltno,3);
    img4=tilts_channels(:,:,tiltno,4);

    [corr_offset(1,:),corr_offset(2,:),corr_offset(3,:),corr_offset(4,:)]=deshift(img1,img2,img3,img4);
    
    shift_avg_pix=(-corr_offset(1,1)-corr_offset(1,2)-corr_offset(2,1)+corr_offset(2,2)+corr_offset(3,1)+corr_offset(3,2)+corr_offset(4,1)-corr_offset(4,2))/8;
    tryshift=shift_avg_pix;
    img1_deshift=imtranslate(img1,-corr_offset(1,:));
    img2_deshift=imtranslate(img2,-corr_offset(2,:));
    img3_deshift=imtranslate(img3,-corr_offset(3,:));
    img4_deshift=imtranslate(img4,-corr_offset(4,:));
    img_gradx_shifted=-(img1_deshift+img2_deshift-img3_deshift-img4_deshift);
    img_grady_shifted=-(img2_deshift-img1_deshift+img3_deshift-img4_deshift);
    iDPC1fft=(1/(1i*2*pi))*((kxp.*(ifftshift(fft2(fftshift(img_gradx_shifted))))+kyp.*(ifftshift(fft2(fftshift(img_grady_shifted)))).*(1-1*(abs(kpnorm2)<0.000000001))))./kpnorm2;
    iDPC1=real(ifftshift(ifft2(fftshift(iDPC1fft))));


    img1_deshift=imtranslate(img1,-corr_offset(1,:)+1*[1 -1]);
    img2_deshift=imtranslate(img2,-corr_offset(2,:)+1*[-1 -1]);
    img3_deshift=imtranslate(img3,-corr_offset(3,:)+1*[-1 1]);
    img4_deshift=imtranslate(img4,-corr_offset(4,:)+1*[1 1]);
    img_gradx_shifted=-(img1_deshift+img2_deshift-img3_deshift-img4_deshift);
    img_grady_shifted=-(img2_deshift-img1_deshift+img3_deshift-img4_deshift);
    iDPC11fft=(1/(1i*2*pi))*((kxp.*(ifftshift(fft2(fftshift(img_gradx_shifted))))+kyp.*(ifftshift(fft2(fftshift(img_grady_shifted)))).*(1-1*(abs(kpnorm2)<0.000000001))))./kpnorm2;
    iDPC11=real(ifftshift(ifft2(fftshift(iDPC11fft))));
    DiDPC1=iDPC11-iDPC1;
    DiDPC1_LP=imgaussfilt(DiDPC1,50);
    DiDPC1_BP=DiDPC1-DiDPC1_LP;
    iDPC11tilt(:,:,tiltno)=DiDPC1_BP;

end

%save iDPC11tilt as mrc file newmRCImage
newmRCImage = MRCImage;%Instentiate MRCImage object
newmRCImage.filename=newFilename11;
newmRCImage = setVolume(newmRCImage, iDPC11tilt); 
newmRCImage.header.cellDimensionX = sizeXangstrom;
newmRCImage.header.cellDimensionY = sizeYangstrom;
save(newmRCImage, newFilename11);
close(newmRCImage);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Process Arina files (96X96 fast mode) as a tilt series, and generate mrc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function function_Arinatomo_rings_v9(mat,Chosen_Filename_file1,nX)
    nY=nX;
    new_mrc_Filename2=strrep(Chosen_Filename_file1,'.h5','_sect');
    param=function_Arina_trackbeam(mat,nX,nY);
    param(1)=0;
    param(4)=0; %we get our own Xd0,Yd0 average center
    
    mask_binning_192=false(192,192);
    for ii=1:2:192
        for j=1:2:192
            mask_binning_192(ii,j)=true;
        end
    end
    [qY, qX] = meshgrid( (1:96)-(1+96)/2,(1:96)-(1+96)/2);
    q=sqrt(qX.^2+qY.^2);
    theta=angle(qX+1i*qY)+pi;
    mask_section=false(96,96,8);
    for t=1:8
        mask=false(96,96);
        mask((theta>=(t-1)*2*pi/8 & theta<t*2*pi/8) & q<=50)=true;
        mask_section(:,:,t)=mask;
        
    end
    
    im_grand=zeros(96,96);
    %%%%%%%%%%  PRELIMINARY TEST / FIND DIFFRACTION CENTER  %%%%%%%%%%%
    pos_temp=1;
    factor_bin=1+1*(length(mat(:,1,1))==192);
    veclength=length(mat(1,1,:));
    for ind=1:veclength
        im=double(mat(:,:,ind));
        if factor_bin==2
            im=reshape(im(mask_binning_192),[192/(factor_bin) 192/(factor_bin)]);
        end
        im_grand=im_grand+im;
        pos_temp=pos_temp+1;
        if pos_temp>nX*nY
            break;
        end
    end
    midv=(max(im_grand(:))+min(im_grand(:)))/2;
    mask=im_grand>midv;
    m_weight=(im_grand.*mask)/sum(sum(im_grand.*mask));
    Xd0=sum(qX(mask).*m_weight(mask));
    Yd0=sum(qY(mask).*m_weight(mask));
    


    radius_disk=round(sqrt(sum(mask(:))/pi));
    mask_com=q<=radius_disk+1;
    
    matview_x(:,1)=ones( 1,1);
    matview_y(:,2)=ones(1,1);
    surfit_view = @(P,XY)  (P(1)+P(2)*XY(:,1) + P(3)*XY(:,2)).*matview_x+(P(4)+P(5)*XY(:,1) + P(6)*XY(:,2)).*matview_y; 


    % ---- Digest for average of first 200 frames
    digest=false;
    if digest
        Tdigest = min(200, veclength);
        S_in = zeros(1,8); S_out = zeros(1,8);
        posX = 1; posY = nY; % same scan order as your code
        for ind = 1:Tdigest
            im_raw = double(mat(:,:,ind));
            if size(im_raw,1)==192
                mask_binning_192 = false(192,192); mask_binning_192(1:2:end,1:2:end) = true;
                im = reshape(im_raw(mask_binning_192), [96 96]);  % MATLAB-exact binning
            else
                im = im_raw;
            end
            val_v = surfit_view(param, [posX posY]);   % same as your code: [xd_pred, yd_pred]
            im_corr = imtranslate(im, [(-Yd0 - val_v(2)) (-Xd0 - val_v(1))], 'FillValues',0);
        
            for t=1:8
                S_in(t)  = S_in(t)  + sum(im_corr(mask_section(:,:,t) & mask_com), 'all');
                S_out(t) = S_out(t) + sum(im_corr(mask_section(:,:,t) & ~mask_com), 'all');
        
                sect_img_in=255*(mask_section(:,:,t) & mask_com);
                newmRCImage = MRCImage;%Instentiate MRCImage object
                newmRCImage.filename=sprintf('%s%g_mask_in.mrc',new_mrc_Filename2,t);
                newmRCImage = setVolume(newmRCImage, sect_img_in); %enter to newmRCImage, do statistics, and fill many details to the header
                save(newmRCImage, sprintf('%s%g_mask_in.mrc',new_mrc_Filename2,t));
                close(newmRCImage);
                sect_img_out=255*(mask_section(:,:,t) & ~mask_com);
                newmRCImage = MRCImage;%Instentiate MRCImage object
                newmRCImage.filename=sprintf('%s%g_mask_out.mrc',new_mrc_Filename2,t);
                newmRCImage = setVolume(newmRCImage, sect_img_out); %enter to newmRCImage, do statistics, and fill many details to the header
                save(newmRCImage, sprintf('%s%g_mask_out.mrc',new_mrc_Filename2,t));
                close(newmRCImage);
            end
            if posX==nX, posX=1; posY=posY-1; if posY==0, break; end
            else, posX=posX+1; end
        end
        disp('DIGEST_MATLAB:')
        disp(struct('Xd0',Xd0,'Yd0',Yd0,'S_in',S_in,'S_out',S_out))
    end


    posX=1;
    posY=nY;
    factor_bin=1+1*(size(mat,1)==192);
    veclength=length(mat(1,1,:));
    scan_grandt=zeros(nX,nY,16);
    for ind=1:veclength

        val_v=surfit_view(param,[posX posY]);

        im=double(mat(:,:,ind));
        if factor_bin==2
            im=reshape(im(mask_binning_192),[192/(factor_bin) 192/(factor_bin)]);
        end
        im_corrected=imtranslate(im,[(-Yd0-val_v(2)) (-Xd0-val_v(1))] ,'FillValues',0);

        for t=1:8
            scan_grandt(posX,posY,t)=sum(sum(im_corrected(mask_section(:,:,t) & mask_com))); %sections inside BF
            scan_grandt(posX,posY,t+8)=sum(sum(im_corrected(mask_section(:,:,t) & ~mask_com))); %sections outside BF
        end
        if posX==nX
            posX=1;
            if posY>1
                posY=posY-1;
            else
                posY=nY;
            end
        else
            posX=posX+1;
        end
    end

   
    vectorti=zeros(1,16);
    for t=1:16
        newmRCImage = MRCImage;%Instentiate MRCImage object
        newmRCImage.filename=sprintf('%s%g.mrc',new_mrc_Filename2,t);
        vol=scan_grandt(:,:,t);
        vectorti(t)=mean(mean(vol(:,:,1)));
        newmRCImage = setVolume(newmRCImage, vol); %enter to newmRCImage, do statistics, and fill many details to the header
        save(newmRCImage, sprintf('%s%g.mrc',new_mrc_Filename2,t));
        close(newmRCImage);
    end

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Track diffraction disc movement by scan 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function param=function_Arina_trackbeam(mat,nX,nY)
    
    [qY, qX] = meshgrid( (1:96)-(1+96)/2,(1:96)-(1+96)/2);
    XY=zeros(nX*nY,2);
    RS=zeros(nX*nY,2);
    XdMAP=zeros(nX,nY);
    YdMAP=zeros(nX,nY);
    index_out=0;
    movingavg_halfsize=round(20*nX/1024); %size of moving average
    
    mask_binning_192=false(192,192);
    for i=1:2:192
        for j=1:2:192
            mask_binning_192(i,j)=true;
        end
    end

    
    %%%%%%  CALCULATE Xd,Yd POSITION OF DIFFRACTION DISK FOR EACH PROBE LOCATION Xp,Yp    %%%%%%%
    Xd=0;
    Yd=0;
    Xp=1;
    Yp=nY;
    veclength=length(mat(1,1,:));
        
    factor_bin=1+1*(length(mat(:,1,1))==192);
    for ind=1:veclength
        if mod(ind,movingavg_halfsize)==0
            vecto_avg=max(max(ind-movingavg_halfsize,ind-Xp+1),1):min(min(ind+movingavg_halfsize,ind+nX-Xp),veclength);
            if length(vecto_avg)>1
                im=mean(double(mat(:,:,vecto_avg)),3);
            else
                im=double(mat(:,:,ind));
            end
            if factor_bin==2
                im=reshape(im(mask_binning_192),[192/(factor_bin) 192/(factor_bin)]);
            end

            meanv=mean(im(:));
            mask=im>meanv; %exclude noise
            m_weight=(im.*mask)/sum(sum(im.*mask));
            
            if ~isempty(mask(:)==true)
                Xd=sum(qX(mask(:)).*m_weight(mask(:)));  
                Yd=sum(qY(mask(:)).*m_weight(mask(:)));
                index_out=index_out+1;
                RS(index_out,1)=Xd; 
                RS(index_out,2)=Yd;
                XY(index_out,1)=Xp; 
                XY(index_out,2)=Yp;
            end
        end
        XdMAP(Xp,Yp)=Xd;
        YdMAP(Xp,Yp)=Yd;
        %Advancing position
        if Xp==nX
            Xp=1;
            Yp=Yp-1;
            if Yp==0
                break;
            end
        else
            Xp=Xp+1;
        end

    end
    
    RS(isnan(RS(:)))=0;
    XY(isnan(XY(:)))=0;
    

    %Shift average position to center (done the same for specimen data)
    RS(:,1)=RS(:,1)-mean(RS(:,1));
    RS(:,2)=RS(:,2)-mean(RS(:,2));

    %%%%%% FIT the data of (Xd,Yd) as fucntion of (Xp,Yp)  %%%%%%%%% 
    XY=XY(1:index_out,:);
    RS=RS(1:index_out,:);
    matout_x(:,1)=ones( index_out,1);
    matout_y(:,2)=ones(index_out,1);
    param0=[0 0 0 0 0 0];
    % Create Objective Function: 
    surfit = @(P,XY)  (P(1)+P(2)*XY(:,1) + P(3)*XY(:,2)).*matout_x+(P(4)+P(5)*XY(:,1) + P(6)*XY(:,2)).*matout_y; 
    options = optimoptions('lsqcurvefit','Algorithm','levenberg-marquardt');
    lb = [];
    ub = [];
    param = lsqcurvefit(surfit,param0,XY,RS,lb,ub,options);
    
end





function [r1,r2,r3,r4]=deshift(im1,im2,im3,im4)
    if sum(abs(im1(:)))>0 && sum(abs(im2(:)))>0 && sum(abs(im3(:)))>0 && sum(abs(im4(:)))>0
        shift_limit=50; 
        do_filt=1;
        r21=r_mn(im2,im1,shift_limit,do_filt);
        r12=-r21;
        r31=r_mn(im3,im1,shift_limit,do_filt);
        r13=-r31;
        r41=r_mn(im4,im1,shift_limit,do_filt);
        r14=-r41;
        r32=r_mn(im3,im2,shift_limit,do_filt);
        r23=-r32;
        r42=r_mn(im4,im2,shift_limit,do_filt);
        r24=-r42;
        r43=r_mn(im4,im3,shift_limit,do_filt);
        r34=-r43;
        A=r21+r31+r41;
        B=r12+r32+r42;
        C=r13+r23+r43;
        D=r14+r24+r34;
        Mfull=[3 -1 -1 -1; -1 3 -1 -1; -1 -1 3 -1; -1 -1 -1 3];
        Mpart=[3 -1 -1; -1 3 -1; -1 -1 3];
        invM=pinv(Mfull); %Moore-Penrose pseudoinverse, effectively 
        rx=invM*[A(2) B(2) C(2) D(2)]';
        ry=invM*[A(1) B(1) C(1) D(1)]';
        zx=Mfull*rx;
        zy=Mfull*ry;
        err1=sqrt(abs(zx(1)-A(2))^2+abs(zy(1)-A(1))^2);
        err2=sqrt(abs(zx(2)-B(2))^2+abs(zy(2)-B(1))^2);
        err3=sqrt(abs(zx(3)-C(2))^2+abs(zy(3)-C(1))^2);
        err4=sqrt(abs(zx(4)-D(2))^2+abs(zy(4)-D(1))^2);
        r1=[rx(1) ry(1)];
        r2=[rx(2) ry(2)];
        r3=[rx(3) ry(3)];
        r4=[rx(4) ry(4)];
    else
        r1=[0 0];
        r2=[0 0];
        r3=[0 0];
        r4=[0 0];
    end
end


function r_mn=r_mn(Imagem,Imagen,shift_limit,do_filt)
    if do_filt==1
        Imagem=imgaussfilt(Imagem-imgaussfilt(Imagem,30),3); %30,3
        Imagen=imgaussfilt(Imagen-imgaussfilt(Imagen,30),3);
    end

    figure(2);
    subplot(1,2,1);
    balanced_imshow(Imagem);
    subplot(1,2,2);
    balanced_imshow(Imagen);
    tempx=floor(0.3*size(Imagem,1));  
    tempy=floor(0.3*size(Imagem,2));
    tempux=size(Imagem,1)-tempx;
    tempuy=size(Imagem,2)-tempy;
    view_in=Imagem(tempx:tempux,tempy:tempuy);
    correlationOutput = normxcorr2(view_in,Imagen);
    [maxCorrValue, maxIndex] = max(abs(correlationOutput(:)));
    [xpeak, ypeak] = ind2sub(size(correlationOutput),maxIndex(1));
    yoffset = ypeak-tempuy;
    xoffset = xpeak-tempux;
    if abs(yoffset)>shift_limit || abs(xoffset)>shift_limit
        correlationOutput = normxcorr2(imgaussfilt(view_in,10),imgaussfilt(Imagen,10));
        [maxCorrValue, maxIndex] = max(abs(correlationOutput(:)));
        [xpeak, ypeak] = ind2sub(size(correlationOutput),maxIndex(1));
        yoffset = ypeak-tempuy;
        xoffset = xpeak-tempux;
        if abs(yoffset)>shift_limit || abs(xoffset)>shift_limit
            r_mn=[0 0];
        else
            r_mn=[xoffset yoffset];
        end
        return;
    end
    %refine to subpixel
    sample16=correlationOutput(xpeak-7:xpeak+8,ypeak-7:ypeak+8);
    Intsample16=fftInterpolate(sample16,[512 512]);

    [maxCorrValue2, maxIndex2] = max(abs(Intsample16(:)));
    [xpeak2, ypeak2] = ind2sub(size(Intsample16),maxIndex2(1));
    yoffset2=yoffset+(ypeak2-256+30)/32;
    xoffset2=xoffset+(xpeak2-256+31)/32;
    r_mn=[xoffset2 yoffset2];
end
